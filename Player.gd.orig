class_name Player extends KinematicBody2D

<<<<<<< working copy
enum Direction{
	NONE,
	LEFT,
	RIGHT
}

var acceleration = 0
export (Curve) var acceleration_curve = Curve.new()
export (Curve) var air_resitance_curve = Curve.new()
export var max_move_speed = 400
export var horizontal_speed_limit = 1800
#export var sprint_speed = 75
export var gravity_force = 9.81
export var jump_force = 240
export var ground_resitance = 25.0
#export var air_resitance = 5.0
export var brake_force = 150
export var knockback_resitance = 75.0
export (bool) var friendly = true

export var current_health = 20
export var max_health = 20

export (NodePath) var camera_path = ""

var velocity = Vector2.ZERO
var direction = Direction.NONE
var is_grounded = false

var is_invincible = false
export var invicibility_time = 1.0

var is_inside_hurt_zone = false
var hurt_zone_damage = 0

export (bool) var show_kill_count = false

signal died
signal enter_floor
signal exit_floor

# Called when the node enters the scene tree for the first time.
func _ready():
	$Camera2D/CanvasLayer/LabeledHealthBar/HealthBar.max_value = max_health
	$Camera2D/CanvasLayer/LabeledHealthBar/HealthBar.value = current_health
	if not show_kill_count:
		$Camera2D/CanvasLayer/KillCount.hide()
	else:
		pass
	AnimationHelper.reconfige_animation_lenght($AnimationPlayer.get_animation("take_damage"), invicibility_time)
	if camera_path != "":
		$Camera2D.current = false
		get_node(camera_path).current = true
		var remote_transform = RemoteTransform2D.new()
		remote_transform.remote_path = "../" + camera_path
		remote_transform.name = "CameraRemoteTransform"
		add_child(remote_transform)
	acceleration_curve.bake()
	air_resitance_curve

func _process(delta):
	$Hand.look_at(get_global_mouse_position())
	if (int(abs($Hand.rotation_degrees)) - 85) % 365 < 365 / 2:
		$Hand/Pistol.flip_v = true
		$Hand/Shotgun.flip_v = true
	else:
		$Hand/Pistol.flip_v = false
		$Hand/Shotgun.flip_v = false
	
	if Input.is_action_just_pressed("shoot_primary"):
		$Hand/Shotgun.visible = true
		$Hand/Pistol.visible = false
		# $AudioStreamPlayer4.play()
	elif Input.is_action_just_pressed("shoot_secondary"):
		$Hand/Shotgun.visible = false
		$Hand/Pistol.visible = true
#		$AudioStreamPlayer3.play()
	
	if is_inside_hurt_zone:
		take_damage(hurt_zone_damage)

func apply_knockback(force, gravity_counter_force = 0.0, movement_counter_force = 0.0, \
horizontal_multiplier = 1.0, vertical_multiplier = 1.0):
		var counter_force =  Vector2.ZERO
		if (force.x > 0 and direction == Direction.LEFT) or (force.x < 0 and direction == Direction.RIGHT):
			if abs(force.x) > knockback_resitance:
				$AccelerationTimer.start()
			if is_on_floor():
				counter_force.x = acceleration * movement_counter_force * (-1 if force.x < 0 else 1)
			else:
				counter_force.x =  acceleration * movement_counter_force * (-1 if force.x < 0 else 1)
			
		# apply gravity counter force
		counter_force.y = -velocity.y * gravity_counter_force if velocity.y > 0 else 0
		force += counter_force
		force.x *= horizontal_multiplier
		force.y *= vertical_multiplier
		
		velocity += force

func jump():
	velocity.y -= jump_force
	is_grounded = false
	$CoyoteTimer.stop()

func limit_x_velocity(max_speed):
	if abs(velocity.x) > horizontal_speed_limit:
		velocity.x = horizontal_speed_limit * (-1 if velocity.x < 0 else 1)

func _physics_process(delta):
	if not (not $CoyoteTimer.is_stopped() and not is_on_floor()) and is_grounded != is_on_floor():
		if is_grounded:
			emit_signal("exit_floor")
		else:
			emit_signal("enter_floor")
	
#	if $AccelerationTimer.time_left / $AccelerationTimer.wait_time != 0:
#		print($AccelerationTimer.time_left, "/", $AccelerationTimer.wait_time, " = ", ($AccelerationTimer.wait_time - $AccelerationTimer.time_left) / $AccelerationTimer.wait_time)
	
	# var speed = sprint_speed if Input.is_action_pressed("sprint") else acceleration
	if direction == Direction.NONE and (Input.is_action_just_pressed("move_left") or Input.is_action_just_pressed("move_right")) and $AccelerationTimer.is_stopped():
		if not $AccelerationTimer.paused:
#			print("Restart!")
			$AccelerationTimer.start()
		else:
#			print("Unpaused!")
			$AccelerationTimer.paused = false
			$MantainAccelerationGracePeriodTimer.stop()
			
#	if (Input.is_action_just_released("move_left") and not Input.is_action_pressed("move_right")) \
#	or (Input.is_action_just_released("move_right") and not Input.is_action_pressed("move_left")):
	if (Input.is_action_just_released("move_left") and direction == Direction.LEFT) or \
	(Input.is_action_just_released("move_right") and direction == Direction.RIGHT):
#		print(direction, " => Paused!")
		$AccelerationTimer.paused = true
		$MantainAccelerationGracePeriodTimer.start()
		$MantainAccelerationGracePeriodTimer.start()
		if is_on_floor() and velocity.x != 0:
			apply_break_force(brake_force)
	
	if  direction != Direction.RIGHT and Input.is_action_pressed("move_left"):
		direction = Direction.LEFT
		$AnimatedSprite.play("Walk")
		acceleration = acceleration_curve.interpolate(($AccelerationTimer.wait_time - $AccelerationTimer.time_left) / $AccelerationTimer.wait_time)
		if velocity.x >= -max_move_speed:
			velocity.x -= acceleration
#			velocity.x -= 
		$AnimatedSprite.flip_h = false
	elif direction != Direction.LEFT and Input.is_action_pressed("move_right"):
		direction = Direction.RIGHT
		acceleration = acceleration_curve.interpolate(($AccelerationTimer.wait_time - $AccelerationTimer.time_left) / $AccelerationTimer.wait_time)
		if velocity.x < max_move_speed:
			velocity.x += acceleration
#			velocity.x += acceleration
		$AnimatedSprite.play("Walk")
		$AnimatedSprite.flip_h = true
	else:
		if is_grounded:
			acceleration = 0
		direction = Direction.NONE
		$AnimatedSprite.play("Idle")
#		if not apply_move_resitance_in_air and is_on_floor() and velocity.x != 0:
#			apply_break_force()
	
	if Input.is_action_just_pressed("jump") and is_grounded:
		jump()
#		$AudioStreamPlayer.play()
	
	velocity.y += gravity_force
	if velocity.x != 0:
		apply_break_force(ground_resitance if is_grounded else get_air_resitance())
	
	limit_x_velocity(horizontal_speed_limit)
	velocity = move_and_slide(velocity, Vector2.UP)
	
func get_air_resitance():
	return air_resitance_curve.interpolate(abs(velocity.x) / horizontal_speed_limit)

func apply_break_force(force):
	if force == 0:
		return
	var breaking_speed = force if velocity.x < 0 else force * -1
	if abs(breaking_speed) > abs(velocity.x):
			breaking_speed = -velocity.x
	velocity.x += breaking_speed

func take_damage(damage = 1):
	if is_invincible or current_health <= 0:
		return
	current_health -= damage
	$Camera2D/CanvasLayer/LabeledHealthBar/HealthBar.value = current_health
	$AnimationPlayer.play("take_damage")
	if current_health <= 0:
		die()
#	$AudioStreamPlayer2.play()

func restart():
	get_tree().reload_current_scene()

func die():
	$AnimationPlayer.play("die")
	print("DEAD!")
	emit_signal("died")

func _on_VictoryZone_win():
	$Camera2D/CanvasLayer/LevelTimer.on_level_cleared()

func collect(coin):
	$Camera2D/CanvasLayer/CollectionDisplay.collected += 1
	
func get_level_stats() -> Dictionary:
	var stats = {}
	stats["time"] = $Camera2D/CanvasLayer/LevelTimer.passed_time
	stats["kills"] = $Camera2D/CanvasLayer/KillCount.kills
	stats["coins"] = $Camera2D/CanvasLayer/CollectionDisplay.collected
	
	return stats


func _on_MantainAccelerationGracePeriodTimer_timeout():
	$AccelerationTimer.paused = false
	$AccelerationTimer.stop()
#	print("Stop!")


func _on_Player_enter_floor():
	$MantainAccelerationGracePeriodTimer.paused = false
	is_grounded = true
	$CoyoteTimer.stop()

func _on_Player_exit_floor():
	$MantainAccelerationGracePeriodTimer.paused = true
	$CoyoteTimer.start()


func _on_CoyoteTimer_timeout():
	is_grounded = false

func pause_animation():
	$AnimatedSprite.playing = false
	
func unpause_animation():
	$AnimatedSprite.playing = true


func _on_PauseMenu_OpenOptions():
	$Camera2D/PauseMenu.hide()
	$Camera2D/OptionsMenu.show()


func _on_OptionsMenu_Return():
	$Camera2D/PauseMenu.show()
	$Camera2D/OptionsMenu.hide()
=======
export var current_health = 20
export var max_health = 20
export var invicibility_time = 1.0

export (NodePath) var camera_path = ""
export (bool) var show_kill_count = false

export (bool) var friendly = true

var is_grounded = false

var is_invincible = false
var is_inside_hurt_zone = false
var hurt_zone_damage = 0

signal died
signal enter_floor
signal exit_floor

# Called when the node enters the scene tree for the first time.
func _ready():
	$Camera2D/CanvasLayer/LabeledHealthBar/HealthBar.max_value = max_health
	$Camera2D/CanvasLayer/LabeledHealthBar/HealthBar.value = current_health
	if not show_kill_count:
		$Camera2D/CanvasLayer/KillCount.hide()
	else:
		pass
	AnimationHelper.reconfige_animation_lenght($AnimationPlayer.get_animation("take_damage"), invicibility_time)
	if camera_path != "":
		$Camera2D.current = false
		get_node(camera_path).current = true
		var remote_transform = RemoteTransform2D.new()
		remote_transform.remote_path = "../" + camera_path
		remote_transform.name = "CameraRemoteTransform"
		add_child(remote_transform)

func _process(delta):
	$Arm.look_at(get_global_mouse_position())
	if (int(abs($Arm.rotation_degrees)) - 85) % 365 < 365 / 2:
		$Arm/Pistol.flip_v = true
		$Arm/Shotgun.flip_v = true
	else:
		$Arm/Pistol.flip_v = false
		$Arm/Shotgun.flip_v = false
	
	if Input.is_action_just_pressed("shoot_primary"):
		$Arm/Shotgun.visible = true
		$Arm/Pistol.visible = false
		# $AudioStreamPlayer4.play()
	elif Input.is_action_just_pressed("shoot_secondary"):
		$Arm/Shotgun.visible = false
		$Arm/Pistol.visible = true
#		$AudioStreamPlayer3.play()
	
	if is_inside_hurt_zone:
		take_damage(hurt_zone_damage)

func apply_knockback(force, gravity_counter_force = 0.0, movement_counter_force = 0.0, \
horizontal_multiplier = 1.0, vertical_multiplier = 1.0):
	$Movement.apply_knockback(force, gravity_counter_force, movement_counter_force, horizontal_multiplier, vertical_multiplier)

func _physics_process(delta):
	if not (not $CoyoteTimer.is_stopped() and not is_on_floor()) and is_grounded != is_on_floor():
		if is_grounded:
			emit_signal("exit_floor")
		else:
			emit_signal("enter_floor")
	$Movement.process()

func take_damage(damage = 1):
	if is_invincible or current_health <= 0:
		return
	current_health -= damage
	$Camera2D/CanvasLayer/LabeledHealthBar/HealthBar.value = current_health
	$AnimationPlayer.play("take_damage")
	if current_health <= 0:
		die()

func restart():
	get_tree().reload_current_scene()

func die():
	$AnimationPlayer.play("die")
	print("DEAD!")
	emit_signal("died")

func _on_VictoryZone_win():
	$Camera2D/CanvasLayer/LevelTimer.on_level_cleared()

func collect(coin):
	$Camera2D/CanvasLayer/CollectionDisplay.collected += 1
	
func get_level_stats() -> Dictionary:
	var stats = {}
	stats["time"] = $Camera2D/CanvasLayer/LevelTimer.passed_time
	stats["kills"] = $Camera2D/CanvasLayer/KillCount.kills
	stats["coins"] = $Camera2D/CanvasLayer/CollectionDisplay.collected
	
	return stats

func _on_Player_enter_floor():
	is_grounded = true
	$CoyoteTimer.stop()

func _on_Player_exit_floor():
	$CoyoteTimer.start()

func _on_CoyoteTimer_timeout():
	is_grounded = false

func pause_animation():
	$AnimatedSprite.playing = false
	
func unpause_animation():
	$AnimatedSprite.playing = true

func _on_Movement_enter_idle():
	$AnimatedSprite.play("Idle")

func _on_Movement_enter_jump():
	is_grounded = false
	$CoyoteTimer.stop()

func _on_Movement_enter_left():
	$AnimatedSprite.play("Walk")
	$AnimatedSprite.flip_h = false

func _on_Movement_enter_right():
	$AnimatedSprite.play("Walk")
	$AnimatedSprite.flip_h = true
>>>>>>> merge rev
